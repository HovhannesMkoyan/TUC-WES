<!DOCTYPE html>
<html>

<head>
    <title>Seminar Web Engineering im Sommersemester 2022 - Comparison of the Frontend Frameworks Vue, React and Svelte
    </title>
    <link rel="stylesheet" type="text/css" href="main.css" />
    <link href='https://fonts.googleapis.com/css?family=Source+Serif+Pro:400,600,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>
    <header>
        <h2>Seminar Web Engineering in Sommersemester 2022</h2>
        <h1>Comparison of the Frontend Frameworks Vue, React and Svelte</h1>
        <h2 class="author">Hovhannes Mkoyan, Zohaib Arshad</h2>
        <h3 class="affiliation">
            Professur Verteilte und Selbstorganisierende Rechnersysteme<br />
            Technische Universität Chemnitz<br />
            Chemnitz, Deutschland
        </h3>
    </header>

    <section>
        <h2>1. Introduction</h2>
        <h5>Hovhannes Mkoyan</h5>
        <p>
            JavaScript is one of the most popular programming languages for creating advanced, interactive, and easily
            maintainable websites. During the last decade, many front-end libraries and frameworks have been built on
            top of JavaScript, making creating, designing, and maintaining interactive websites easier. Those frameworks
            are the well-known React, Vue.js, and the relatively new Svelte.
        </p>
        <p>
            In this report, these three technologies are discussed one by one, will compare them, and show the
            comparison results. The criteria for evaluation are mainly based on the speed of completing certain
            operations related to DOM elements in the web browser, such as DOM element addition, editing, and removal.
            Evaluation criteria that are non-technical include things like variations in architecture, development
            experience, popularity, maturity, and availability.
        </p>
        <h3>1.1. Framework vs Library </h3>
        <h5>Hovhannes Mkoyan</h5>
        <p>
            The technologies that will be discussed can be defined with one or two of the following terms:
            framework and
            library.<br />
            The terms library and framework refer to different things; however, they are very often interchanged with
            each other in the same context.
            Before getting into the key differences between these words, there is a common purpose that they both serve.
            Libraries and frameworks are some code written by developers to solve complicated problems efficiently. They
            both give us a better approach to writing DRY (don't repeat yourself) code.<br />
            However, a framework tells what to do. It has the "right way" of doing things and provides tooling to
            support
            developers. Some of the tools can be:
        </p>
        <ul>
            <li>State management</li>
            <li>Handling forms</li>
            <li>Routing</li>
            <li>HTTP</li>
            <li>Testing</li>
        </ul>
        <p>Two perfect examples of a framework are Vue.js and Angular.<br />
            On the other hand, libraries are utilities built for a singular purpose. For example,
        </p>
        <ul>
            <li>React creates UIs</li>
            <li>Redux provides state management</li>
            <li>JQuery provides cross-browser DOM manipulation</li>
        </ul>
        <p>The technical difference between a framework and a library lies in a term called inversion of control (IoC).
            When using a library, a user is in charge of the flow of the application. The user chooses when and where to
            call the library. When using a framework, the framework is in charge of the flow. It provides some places
            for a user to plug in his/her code, but it calls the code plugged in as needed.
        </p>
        <figure>
            <img src="framework-vs-library.png" alt="Framework vs Library" />
            <figcaption>
                <strong>Figure 1</strong>: Difference between a library and a framework <a href="#r7">[7]</a>.
            </figcaption>
        </figure>
    </section>

    <section>
        <h2>2. React</h2>
        <h5>Hovhannes Mkoyan</h5>
        <p>
            React (also known as React.js) is a JavaScript library developed by Facebook. React was first released in
            May 2013. React has a narrow scope and single focus, which is rendering the application user interface in an
            efficient way using declarative code. As a result, it has a lightweight structure and is less costly to
            learn and use. Quite often, React is called a framework, although it is a library, and the reason for that
            is that it is a direct competitor of top JavaScript frameworks like Vue.js and Angular.
        </p>
        <p>React has a component-based architecture. A component is one of the main building blocks of React. Every
            application one will develop in React will be made up of pieces called components which are separate blocks
            that act independently of each other. In this way, components make the task of building UIs much easier.
        </p>
        <p>Every React component is made of two main ingredients: state and props.<br /> A state is a built-in object
            that contains all the data or information about a component. A component's state can change over time, and
            whenever it does, the component re-renders as a result. State change can happen as a response to user action
            or system-generated events, and these changes determine the component's behavior and how it will render.
            <br />
            Props are used to pass data from one component to another (from a parent component to a child component).
        </p>
        <figure>
            <img src="state-vs-props.png" alt="Props & State" />
            <figcaption>
                <strong>Figure 2</strong>: Props and state <a href="#r11">[11]</a>.
            </figcaption>
        </figure>
        <p>In addition, every component has "lifecycle methods." They specify the behavior of a component when it
            undergoes different phases of its lifecycle. Some examples of different phases could be: when the component
            is just about to render on the screen, when it has rendered on the screen, or when it is updated/modified in
            response to a request or a user-triggered action.
        </p>
        <h3>2.1. Virtual DOM </h3>
        <h5>Hovhannes Mkoyan</h5>
        <p>Virtual DOM (VDOM) is a programming concept where a "virtual" representation of a UI is kept in memory
            and synchronized with the "real" DOM. This process is called reconciliation. This approach enables the
            declarative API of React, which means we tell React what state we want the UI to be in, and it makes sure
            the DOM matches that state. This abstracts out the attribute manipulation, event handling, and manual DOM
            updating that we would otherwise have to use to build our application <a href="#r8">[8]</a>.
        </p>
        <p>
            The two React ingredients, state, and props, mean we can organize our components in a hierarchical structure
            or a tree that ensures a one-way data flow. <br />
            As mentioned, React never updates the original DOM directly (unless a developer use case requires
            it). In this picture, we can see the reconciliation process through which React updates the DOM.
        </p>
        <ul>
            <li>First of all, React creates a copy of the original DOM, the Virtual DOM. Each of the nodes (circles) of
                the Virtual DOM represents an element or component.
            </li>
            <li>Next, a new Virtual DOM is created if there is a state update of an element. </li>
            <li>The diffing algorithm identifies what has changed. In this case, we can see that new nodes
                “d” and “e” are being added to “c,” so the “c” node has been identified as the difference or the diff.
            </li>
            <li>Lastly, React runs a batch update to update the Original DOM with these changes to keep it in sync.
            </li>
        </ul>
        <figure>
            <img src="ReactVirtualDOM.png" alt="React VDOM" />
            <figcaption>
                <strong>Figure 3</strong>: React Virtual DOM <a href="#r10">[10]</a>.
            </figcaption>
        </figure>
    </section>

    <section>
        <h2>3. Svelte</h2>
        <h5>Hovhannes Mkoyan</h5>
        <p>
            Although usually mistakenly referred to as a framework, as in the case of React, Svelte is actually a
            compiler that was created by Rich Harris and released in November 2016. It provides a different approach to
            building web apps than some of the other frameworks covered. While like React and Vue do the most
            significant part of their work in a browser while the application is running, Svelte shifts that work into a
            compile step that happens only when a user builds the application, producing highly optimized vanilla
            JavaScript. As a result, the application needs no dependencies to start, and no overhead framework code is
            injected into the browser. That is why Svelte bundle size leaves a far smaller footprint than other
            frameworks.
        </p>
        <p>This approach not only produces smaller application bundles and better performance but also has a better
            developer experience that is more pleasant for people who do not have much experience in the modern tooling
            ecosystem. Like React, Svelte too has a component-based architecture. A Svelte component may contain three
            sections: script, style, and template. The first two, which modify the component's appearance and behavior,
            are optional, but the template section is required. So, Svelte sticks to the classic web development model
            of HTML, CSS, and JS, just adding a few extensions to HTML and JavaScript. As a result, it arguably has
            fewer concepts and tools to learn than some of the other framework options.
            <br />Svelte extends vanilla web technologies in the following ways:
        </p>
        <ul>
            <li>It extends HTML by allowing the use of JavaScript expressions in markup and providing directives to use
                conditions and loops in a fashion similar to handlebars.
            </li>
            <li>It extends CSS by adding a scoping mechanism, allowing each component to define its own styles without
                the risk of clashing with other components' styles.
            </li>
            <li>It extends JavaScript by reinterpreting specific language directives to achieve true reactivity and ease
                component state management <a href="#r9">[9]</a>.
            </li>
        </ul>
        <p>Svelte compiles the code, so it does not have to use a virtual DOM, bringing some performance improvements.
            It surgically updates the DOM without relying on an intermediary or complex reconciliation technique.
            Svelte's compiler tracks changes in variables and updates the HTML accordingly. It looks through a code,
            watches for components that depend on variables, and then updates those components as the variables change.
            This way, Svelte is reactive without relying on a third-party API.
        </p>
        <p>Below are two snippets of React and Svelte code. Of course, the snippets' result is the same, but clearly,
            Svelte code is much easier to understand.
        </p>
        <figure>
            <pre><code>
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(&lt;h1>Hello, world!&lt;/h1>);</code>
            </pre>
            <figcaption>
                <strong>Figure 4</strong>: React - Hello World.
            </figcaption>
        </figure>
        <figure>
            <pre><code>
                &lt;h1>Hello, World!&lt;/h1></code>
            </pre>
            <figcaption>
                <strong>Figure 5</strong>: Svelte - Hello World.
            </figcaption>
        </figure>
    </section>

    <section>
        <h2>4. Vue.js</h2>
        <h5>Zohaib Arshad</h5>
    </section>

    <section>
        <h2>5. Demo</h2>
        <h5>Hovhannes Mkoyan</h5>
        <p>We did three different DOM benchmarks for each technology in the demo. There are three basic operations:
            insertion, updating, and removal. The time for each of these operations has been measured using one of the
            Web APIs named Performance interface that provides access to performance-related information, so the
            interface is native to JavaScript and thus available in all of the three technologies. The first timestamp
            was recorded programmatically at the click of a button, and the second timestamp was recorded once the DOM
            event that tracks a DOM update was recorded.
            <br />Each test case was run 20 times; the results are the averages in milliseconds.<br />
            React version benchmarked was 18.1.0, Vue version was 3.2.37, Svelte version was 3.0.0. The browser used for
            testing purposes was Google Chrome, Version 102.0.5005.61.
            <br />The code snippet below shows the structure of a single todo element.
        </p>
        <figure>
            <pre>
                <code>
                    &lt;div>
                    &nbsp; &lt;div>
                    &nbsp; &nbsp; &lt;svg>&lt;/svg>
                    &nbsp; &nbsp; &lt;span>&lt;/span>
                    &nbsp; &lt;/div>
                    &nbsp; &lt;div>
                    &nbsp; &nbsp; &lt;svg>&lt;/svg>
                    &nbsp; &nbsp; &lt;svg>&lt;/svg>
                    &nbsp; &lt;/div>
                    &lt;/div>
                </code>
            </pre>
            <figcaption>
                <strong>Figure 6</strong>: Single todo HTML element structure.
            </figcaption>
        </figure>
        <p>In the addition test, Svelte has the fastest performance. However, the performance difference with React is
            not that big, and these two performed relatively well. The notable outlier is Vue, which has a slower
            average performance, at 9809 milliseconds.
            <br />In one of the sources by Mattias Levlin, who did a DOM benchmark comparison too, the author does the
            same test by adding 10.000 &lt;div> elements, each containing a &lt;p> element with text data. React, and
            Svelte had the same similar performance
            in his test as in our case; however, React was slightly faster than Svelte.
        </p>
        <figure>
            <img src="demo - addition test.png" alt="Addition results" />
            <figcaption>
                <strong>Figure 7</strong>: Addition results (in milliseconds).
            </figcaption>
        </figure>
        <p>The second benchmark phase is the DOM updating performance; an update of 10000 elements previously added
            to the DOM was performed. Specifically, the time to change all todos text has been calculated. Here, the
            situation is different compared to the previous benchmark. We can see that Vue.js is almost two times
            faster than React, and Svelte does the job at a blazingly fast pace, taking only 67 milliseconds on
            average. Svelte performs this fast in Levln’s update test too, but only when updating a single todo.
            However, when updating all the 10000 elements, React, and Vue.js produce the best results.
        </p>
        <figure>
            <img src="demo - updating.png" alt="Updating results" />
            <figcaption>
                <strong>Figure 8</strong>: Updating results (in milliseconds).
            </figcaption>
        </figure>
        <p>In the third benchmark phase, a DOM removal operation was performed, removing 10,000
            &lt;div> elements with all the content.
            In this benchmark, React had the fastest performance, at 315 milliseconds, while Vue.js and Svelte
            showed relatively slow performance, at an average of 478 and 462 milliseconds, аccordingly.
        </p>
        <figure>
            <img src="demo - removal.png" alt="Removal results" />
            <figcaption>
                <strong>Figure 9</strong>: Removal results (in milliseconds).
            </figcaption>
        </figure>
        <p>To conclude, for the above specific tests, for the given technology versions and the environment,
            React was the fastest technology in one of the three tests (when removing) and the slowest when
            updating. On the other hand, Svelte was the fastest in two tests when adding and updating.
            Furthermore, although Vue.js is two times faster than React when updating, it showed the worst
            results in adding and removal tests.
        </p>
    </section>

    <section class="references">
        <h2>6. Bibliography</h2>
        <p class="reference" id="r1">[1] Alexander, S.L. (2015). Speed Performance Comparison of JavaScript MVC
            Frameworks.</p>
        <p class="reference" id="r2">[2] Levlin, M., Soini, A., & Truscan, D. (2020). DOM benchmark comparison of the
            front-end JavaScript frameworks React, Angular, Vue, and Svelte.</p>
        <p class="reference" id="r3">[3] Risto Ollila (2021). A performance comparison of rendering strategies in open
            source web frontend frameworks.
        </p>
        <p class="reference" id="r4">[4] React Docs. [Online]. Available: <a
                href="https://reactjs.org/docs/getting-started.html">https://reactjs.org/docs/getting-started.html</a>
            (18.06.2022)</p>
        <p class="reference" id="r5">[5] Svelte Docs. [Online]. Available: <a
                href="https://svelte.dev/docs">https://svelte.dev/docs</a>
            (18.06.2022)</p>
        <p class="reference" id="r6">[6] Vue Js Guide. [Online]. Available: <a
                href="https://v2.vuejs.org/v2/guide/">https://v2.vuejs.org/v2/guide/</a>
            (23.06.2022)</p>
        <p class="reference" id="r7">[7] Ledion S. (2015, April). What's the difference between a library and a
            framework? [Online]. Available: <a
                href="https://www.linkedin.com/pulse/whats-difference-between-library-framework-ledion-spaho/">https://www.linkedin.com/pulse/whats-difference-between-library-framework-ledion-spaho/</a>
            (27.06.2022)</p>
        <p class="reference" id="r8">[8] Virtual DOM and Internals [Online]. Available <a
                href="https://reactjs.org/docs/faq-internals.html">https://reactjs.org/docs/faq-internals.html</a>
            (22.06.2022)
        </p>
        <p class="reference" id="r9">[9] Getting started with Svelte. [Online]. Available: <a
                href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_getting_started">https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_getting_started</a>
            (22.06.2022)
        </p>
        <p class="reference" id="r10">[10] Aadyaa M. (2021). Introduction to React. SE-EDU. [Online]. Available: <a
                href="https://se-education.org/learningresources/contents/javascript/Javascript-framework-React.html">https://se-education.org/learningresources/contents/javascript/Javascript-framework-React.html</a>
            (20.06.2022)</p>
        <p class="reference" id="r11">[11] React States. [Online]. Available: <a
                href="https://www.c-sharpcorner.com/article/react-states-day-six/">https://www.c-sharpcorner.com/article/react-states-day-six/</a>
            (30.06.2022)</p>
    </section>
</body>

</html>